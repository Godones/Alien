# 技术方案

这个技术方案描述了我们如何实现一个隔离的操作系统内核。

## 概述

现代主流操作系统由内核和用户程序两部分构成，而内核又由诸多复杂的子系统构成，例如文件子系统，网络子系统，以及许多驱动模块。内核不断增加的代码以及使用不安全的编程语言使得内核的安全性面临严峻挑战。为了让内核更加安全，内核引入了许多技术和工具来防止用户利用漏洞攻击和窃取内核信息。内核的这些子系统与其它代码都位于内核空间当中，互相之间包含了复杂的依赖关系，这导致了单个模块出现的漏洞也会造成其它模块崩溃，内核子系统缺乏隔离性是导致这个现象的主要原因。目前的许多工作开始利用一些先进的硬件手段来实施内核子系统的隔离，但这些硬件手段缺乏灵活性同时可能会造成较大的性能损失，不能广泛应用在内核开发当中。随着编程语言的发展，一些兼顾性能和内存安全的语言被提出(例如rust)，这让我们可以利用现代编程语言来实现实用的、轻量级的、细粒度的隔离以及一系列机制。我们开发一个完全使用Rust语言的操作系统，并利用语言机制对内核各个子系统进行隔离(内存隔离/故障隔离)，在此基础上，我们对隔离域的故障恢复进行探索。



## 可信基/Threat Model

在许多文章中，这个部分也被称为`TCB` 或者 `Threat Model`， 这主要描述了在隔离的系统中，始终存在一部分代码是不安全的但是又必须存在的，比如说内核的启动代码，内存管理，甚至是任务调度，我们把这些部分作为TCB的一部分，将其视为安全的，可信的。同时，隔离的模型不能完全地解决所有的漏洞，因此我们需要对系统做出一些假设。

对于非核心子系统，其是不可信的，因此需要使用安全的语言进行编写，我们假设安全的rust语言可以提供内存安全性。

安全语言提供了四个对于在软件中提供内存隔离至关重要的保证:

1. 它们不允许指针算术，并要求代码获取的任何引用要么是由于分配或函数调用而生成的； 
2. 它们检查数组访问的边界，从而防止由于缓冲区溢出（和下溢）而导致的杂散内存访问； 
3. 它们不允许访问空对象，从而防止应用程序使用未定义的行为来访问应隔离的内存； 
4. 它们确保所有类型转换都是安全的（并且在兼容对象之间）

因为内核需要与硬件进行交互，不安全的代码的存在是必要的，这些非核心子系统就必然会使用一些不安全的功能，我们假设对这些不安全操作的安全封装是正确的，不会触发非法操作。

## 目标

我们利用安全的语言来实现内核的各个子系统，我们的主要目标是利用语言机制，实现各个子系统的内存隔离、故障隔离以及故障恢复。

### 内存隔离

所谓内存隔离，就是说这些隔离的子系统之间自成一个整体，他们拥有自己的数据，同时，他们不会引用或者拥有其它域的数据，更近一步的，他们不能通过非法途径访问其它隔离子系统的数据。对于隔离系统之间的通信(函数调用)，他们只能通过共享的区域传递数据(调用参数)。

基于硬件机制进行隔离的系统通常对内存页进行标记来区分各个隔离域之间对内存页的访问权限。而基于语言机制的软件隔离方法使用安全的语言来保证隔离域对内存的正确访问。

在内存隔离的基础上，我们可以实现隔离区域的**零拷贝通信**：通信不需要对传递的数据的额外拷贝

### 故障隔离

这里我们沿用了`redleaf`中的故障隔离定义。当进入域的线程之一发生panic时，我们说域崩溃(panic)并需要终止。panic可能会使域内部可访问的对象处于不一致的状态，从而使域内任何线程的进一步进展变得不切实际（即，即使线程没有死锁或恐慌，计算结果也是不确定的）如果满足以下条件，我们就说故障是隔离的：

1. **可以将崩溃域内运行的所有线程展开到域入口点并向调用者返回错误**
2. **随后尝试调用域会返回错误，但不会违反安全保证或导致panic**
3. **崩溃域的所有资源都可以安全地释放，即其他域不保留对崩溃域的堆的引用（堆隔离不变式），并且我们可以回收该域拥有的所有资源而不会泄漏**
4. **其他域中的线程继续执行，并且可以继续访问由崩溃的域分配但在崩溃之前移动到其他域的对象。**

### 故障恢复

在故障隔离的基础上，我们可以针对一些隔离域实施故障恢复。故障恢复则是指在域发生崩溃并且资源已经被完全回收的情况下，对域进行重新加载和初始化，使其恢复正常的状态。在此之后，域将会重新开始工作。



## 实现

这部分描述了如何在Rust语言中实施三个主要的目标。

### 接口定义

每个隔离域都向外提供功能，这些功能使用rust的`trait` 进行表示。系统启动后会加载各个隔离域，并得到一个代表隔离域的对象。

```rust
pub trait BlkDevice: Send + Sync {
    fn read(&self, block: u32, data: RRef<[u8; 4096]>) -> RpcResult<RRef<[u8; 4096]>>;
    fn write(&self, block: u32, data: &RRef<[u8; 4096]>) -> RpcResult<usize>;
    fn get_capacity(&self) -> RpcResult<u64>;
}
```

### 内存隔离

1. 使用`safe rust` 实现各个隔离的子系统：这意味着实现中不允许出现任何`unsafe` 操作
2. 使用两级内存分配器管理整个系统的内存和隔离域的内存
   1. 第一级分配器用于向隔离域分配页大小的内存
   2. 第二级分配器负责隔离域内部的小粒度内存分配，这通常是指rust的`[global_allocator]`
3. 封装不安全的低级操作：一些隔离域必须与低级的硬件进行交互，我们需要将对硬件的访问封装在安全的rust中。
   1. 隔离域只能依赖我们提供的安全封装实现上层逻辑
   2. 隔离域可以依赖TCB请求一些必要功能
4. 使用共享堆来进行域间通信
   1. 共享堆限制了在域间通信时传递的数据，避免隔离域拥有其它域的数据
   2. 利用rust的所有权机制，使得传递的数据只能有一个所有者，这可以避免数据传递后被原来的域所修改
   3. 通过移动数据的所有权，或者使用不可变数据，我们可以避免对数据的额外拷贝

### 故障隔离

为了强制执行故障隔离，我们需要依靠调用代理来干预所有跨域调用。为了确保隔离和安全，代理在每个包装函数内实现以下内容：

1. 代理在执行调用之前检查域是否处于活动状态。如果域处于活动状态，代理会通过更新内核中的状态来记录线程在域之间移动的事实。当域崩溃时，我们使用此信息来展开域内执行的所有线程
2. 对于每次调用，代理都会创建一个轻量级延续，捕获跨域调用之前线程的状态。延续允许我们展开线程的执行，并向调用者返回错误。
3. 代理移动作为域之间参数传递的所有 RRef<T> 的所有权，或更新所有不可更改借用的引用的借用计数

代理只是对域对象的简单封装。

### 故障恢复

我们的故障恢复目前只会针对几个简单的隔离子系统(几个驱动程序)。

- 为了实现故障恢复，隔离域可能需要保存初始化域所需的资源，比如其它隔离域的对象引用。
- 针对可恢复的隔离域，在执行故障隔离时，线程的展开并不会返回错误，代理对象会尝试重新对隔离域进行初始化，并再次执行跨域调用。

- 需要注意的是当跨域调用时如果我们使用不可变参数进行通信时，对隔离域的重新调用可以不需要额外的拷贝，对于使用拥有所有权的参数进行通信时，为了实施对隔离域的重新调用，我们需要对参数进行拷贝。



## 规划

我们会按照几个阶段逐步将已有的Alien OS内核转变成一个隔离的内核。

- [x] 原型系统的验证：这一阶段主要是对隔离的几个核心概念做一个简单的演示，以验证使用rust语言实现的可行性。

- [ ] 对隔离子系统的划分：内核中有多个子系统，我们需要考察如何划分子系统才可以做到性能和隔离效果兼顾

  - 粒度大意味着接口可以更简单，域间通信的次数更少，带来的开销也减小，但因为隔离边界的扩大导致隔离域出现故障的概率更高了
  - 粒度小则可能会让系统内部的隔离域数量增大，导致频繁的域间通信，开销增大，但是较小的边界可以把错误限制在更小的范围

  - [ ] 目前的想法暂定的几个隔离域：
    - [ ] 设备驱动: 块设备+网络设备
    - [ ] 文件系统 + 虚拟文件系统
    - [ ] 系统调用

- [ ] 隔离域实现的基础设施

  - [ ] 对内核TCB的功能依赖：两级分配器 + 共享堆
  - [ ] 各个驱动域依赖的硬件安全封装
  - [ ] 接口定义和代码自动生成

- [ ] 实现各个隔离域并组装完整的系统

- [ ] 测试

在每个实施阶段，我们都可能对其中的机制或方法进行修改和修正。
