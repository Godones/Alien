# 技术方案

这个技术方案描述了我们如何实现一个隔离的操作系统内核。

## 概述

现代主流操作系统由内核和用户程序两部分构成，而内核又由诸多复杂的子系统构成，例如文件子系统，网络子系统，以及许多驱动模块。内核不断增加的代码以及使用不安全的编程语言使得内核的安全性面临严峻挑战。为了让内核更加安全，内核引入了许多技术和工具来防止用户利用漏洞攻击和窃取内核信息。内核的这些子系统与其它代码都位于内核空间当中，互相之间包含了复杂的依赖关系，这导致了单个模块出现的漏洞也会造成其它模块崩溃，内核子系统缺乏隔离性是导致这个现象的主要原因。目前的许多工作开始利用一些先进的硬件手段来实施内核子系统的隔离，但这些硬件手段缺乏灵活性同时可能会造成较大的性能损失，不能广泛应用在内核开发当中。随着编程语言的发展，一些兼顾性能和内存安全的语言被提出(例如rust)，这让我们可以利用现代编程语言来实现实用的、轻量级的、细粒度的隔离以及一系列机制。我们开发一个完全使用Rust语言的操作系统，并利用语言机制对内核各个子系统进行隔离(内存隔离/故障隔离)，在此基础上，我们对隔离域的故障恢复进行探索。



## 可信基/Threat Model

在许多文章中，这个部分也被称为`TCB` 或者 `Threat Model`， 这主要描述了在隔离的系统中，始终存在一部分代码是不安全的但是又必须存在的，比如说内核的启动代码，内存管理，甚至是任务调度，我们把这些部分作为TCB的一部分，将其视为安全的，可信的。同时，隔离的模型不能完全地解决所有的漏洞，因此我们需要对系统做出一些假设。

对于非核心子系统，其是不可信的，因此需要使用安全的语言进行编写，我们假设安全的rust语言可以提供内存安全性。

安全语言提供了四个对于在软件中提供内存隔离至关重要的保证:

1. 它们不允许指针算术，并要求代码获取的任何引用要么是由于分配或函数调用而生成的； 
2. 它们检查数组访问的边界，从而防止由于缓冲区溢出（和下溢）而导致的杂散内存访问； 
3. 它们不允许访问空对象，从而防止应用程序使用未定义的行为来访问应隔离的内存； 
4. 它们确保所有类型转换都是安全的（并且在兼容对象之间）

因为内核需要与硬件进行交互，不安全的代码的存在是必要的，这些非核心子系统就必然会使用一些不安全的功能，我们假设对这些不安全操作的安全封装是正确的，不会触发非法操作。

## 目标

我们利用安全的rust语言来实现内核的各个子系统，我们的主要目标是利用语言机制，实现各个子系统的内存隔离、故障隔离以及故障恢复。

这个目标分为两个阶段进行实施：

1. 在Alien OS上进行隔离域的划分和具体实现，因为Alien要针对不同平台进行支持导致难以对系统进行更进一步的划分，因此这里我们会只针对Qemu平台来完成一个特化版本的OS，这个OS保留绝大部分的功能，但丢失一些真实开发板的支持和通用性代码
2. 在Linux中引入隔离相关的基础设施，并将Alien中几个隔离域应用到Linux中

###  几个主要的问题

1. 隔离
2. 通信
3. 操作系统支持(基础设施)
4. 状态保存和恢复

系统由隔离的子系统构成，这些子系统向下依赖于操作系统提供的基础设施与其它的子系统，向上为其它子系统与和操作系统提供功能。每个子系统被限制在一个独立的空间，不能互相引用，只能通过公开的接口进行调用。为了进行各个子系统的协作，每个隔离域公开的接口都包含了不同的参数，我们需要支持这些隔离域的通信，并保证隔离性，因此引入了共享堆对参数进行了限制。虽然这些隔离域比较独立，但他们都会依赖一组操作系统提供的功能，为了最小化这个依赖，我们尽量保持一组最小的操作系统原语，并在此基础上构建其它隔离子系统。



### 隔离

#### 内存隔离

所谓内存隔离，就是说这些隔离的子系统之间自成一个整体，他们拥有自己的数据，同时，他们不会引用或者拥有其它域的数据，更近一步的，他们不能通过非法途径访问其它隔离子系统的数据。对于隔离系统之间的通信(函数调用)，他们只能通过共享的区域传递数据(调用参数)。

基于硬件机制进行隔离的系统通常对内存页进行标记来区分各个隔离域之间对内存页的访问权限。而基于语言机制的软件隔离方法使用安全的语言来保证隔离域对内存的正确访问。

在内存隔离的基础上，我们可以实现隔离区域的**零拷贝通信**：通信不需要对传递的数据的额外拷贝

#### 故障隔离

这里我们沿用了`redleaf`中的故障隔离定义。当进入域的线程之一发生panic时，我们说域崩溃(panic)并需要终止。panic可能会使域内部可访问的对象处于不一致的状态，从而使域内任何线程的进一步进展变得不切实际（即，即使线程没有死锁或恐慌，计算结果也是不确定的）如果满足以下条件，我们就说故障是隔离的：

1. **可以将崩溃域内运行的所有线程展开到域入口点并向调用者返回错误**
2. **随后尝试调用域会返回错误，但不会违反安全保证或导致panic**
3. **崩溃域的所有资源都可以安全地释放，即其他域不保留对崩溃域的堆的引用（堆隔离不变式），并且我们可以回收该域拥有的所有资源而不会泄漏**
4. **其他域中的线程继续执行，并且可以继续访问由崩溃的域分配但在崩溃之前移动到其他域的对象。**

#### 故障恢复

在故障隔离的基础上，我们可以针对一些隔离域实施故障恢复。故障恢复则是指在域发生崩溃并且资源已经被完全回收的情况下，对域进行重新加载和初始化，使其恢复正常的状态。在此之后，域将会重新开始工作。

故障恢复目前只会针对一些无状态的域，比如驱动程序，其内部通常不会保存一些额外的状态。而其它隔离域可能因为内部保存的状态在运行过程中被外部输入所影响而导致发生了变化，这种域因为我们保存域内部状态的机制，因此无法恢复到正确的状态。

### 通信



## 域的动态加载和更新

在域的故障恢复中，已经包含了部分的域动态加载和更新的功能，这里的适用范围更广，所完成的功能更多。

域动态加载：

1. 系统启动初期可以只加载最基本的域来建立基本的内核功能，稍后可选地从网络中/磁盘上加载其它扩展的域到内核中<font color = red> 内核主动</font>
2. 由用户请求加载到内核的域 <font color = red> 用户通过系统调用，内核被动</font>

域更新：

1. 域发生故障，被重启  <font color = red> 内核主动</font>
2. 域无故障，由用户请求进行更新   <font color = red> 用户通过系统调用，内核被动</font>
3. 原本没有这个域，新增一个域 <font color = red> 用户通过系统调用，内核被动</font>

对于更新来说：

1. 如果内核原本没有这个域，新增一个域，那么就没有域状态迁移的相关要求。**这里主要考虑如何在实现代码的时候可以允许新的域功能添加后被正常使用**。
2. 如果是其它两种情况，则需要考虑域的状态管理和迁移的内容。

主要问题：

1. 什么时候可以更新一个域？
2. 如何完成数据状态的迁移？

### 状态

一个域内部包含了各种代码、数据，这这些内容构成了一个域的运行状态。

#### 无状态的模块

对于一些逻辑算法来说，只有明确的输入和明确的输出，这种程序是无状态的。但是对操作系统内核来说，不存在只有逻辑的模块，每个模块内部都有自己的数据。对于许多模块，这里的无状态指的是模块内部的数据是无关紧要的，不需要在更新的时候考虑。

这种模块经常来自设备驱动部分。

#### 数据有状态的模块

除了那些无状态的模块，其余的模块都应该分类到有状态的部分，这些模块的更换必须随着内部的数据一起更换，因为模块的逻辑依赖于这些内部的数据。

诸如任务调度器 / 任务管理 / 以及驱动在内核的进一步封装层等属于这一类

#### 什么时候可以更新？

状态静止的概念：让系统处于一个静止状态

#### 如何完成有状态模块的数据迁移？

如何建模这些数据？

1. 集中式的管理 ： 将数据和逻辑分离
2. 程序分析：通过编译器为所有数据生成元数据信息

##### 集中式管理

将数据与逻辑分离，意味着需要一个地方来存储和读取数据。这种方法会带来设计上的修改，即需要明确数据如何保存？如何快速读取？再根据存储的方式实现具体的逻辑。

在最近的[DBOS]()相关的论文中，提出了一种数据库操作系统，将数据存储在分布式的存储系统上，并通过数据库的数据索引方式建模操作系统。这种方式每次都需要将数据进行序列存储和反序列化读取，而且无法表达一些操作系统的概念，比如锁、引用计数等，似乎不太能适用。

##### 程序分析

一些文章中对不同的内核模块做数据迁移时根据的是程序的符号信息，通过在旧模块中找到对应符号，可以将旧模块的数据拷贝到新的模块中。



|          | 集中式管理                     | 程序分析 |
| -------- | ------------------------------ | -------- |
| 数据保存 | 保存在一个地方，被新旧模块复用 |          |
|          |                                |          |
|          |                                |          |



##### 如何根据建模的方法完成迁移？

如果使用集中式管理，数据将被存储在一个地方，并被新旧模块复用。那么数据旧不需要迁移。<font color = red>这里产生一个新的问题：如果数据存储方式发生了改变，新的模块是否怎么感知到变化，怎么能正确地找到数据？</font>。



> ## 启发
>
> 是不是有状态模块的状态有个最小子集，我们只需要关注最小子集的数据即可？





### Linux扩展

因为Alien内核与linux有相似之处，并且社区正在不断推进rust for Linux，已经有使用rust实现的驱动进入内核当中，相信可以将我们实现的隔离域逐步地引入到内核当中。目前这是一个设想，还缺乏对rust for Linux的进一步探索。

- [x] [An incremental path towards a safer OS kernel](https://dl.acm.org/doi/10.1145/3458336.3465277)
- [x] [Practical Safe Linux Kernel Extensibility](https://dl.acm.org/doi/10.1145/3317550.3321429)
- [x] [Evolving Operating System Kernels Towards Secure Kernel-Driver Interfaces](https://dl.acm.org/doi/10.1145/3593856.3595914)

这几篇文章描述了向Linux中逐步引入安全内核扩展的愿景，一些团队也已经开始在尝试这方面的工作。

## 设计

**模块/域的区别和联系**

这里的模块指的是可被重用的crate。通常许多设备驱动程序都是一个独立的模块，可被多个系统所使用，但这些模块内部通常缺乏我们的safe rust约束，即其内部可能包含了一些unsafe的操作，或者其依赖项中依赖了unsafe操作。我们的设计就是使得除了最核心的TCB可使用unsafe操作之外，其它外部设施都有safe代码构成，因此这些模块在这个层面上是不满足要求的。而要使得一个模块以及其依赖完全由safe rust编写，理论上也是不太可能的，这也是为什么我们需要为外部设施搭建一个最小的安全抽象层。

如果这个模块使用了这个最小的安全抽象层，那它的模块化程度可能就不是那么好，因为它依赖的抽象层是针对我们这个系统的。一个直观的想法是==是否可以用rust的trait来让这个模块的那些unsafe操作由外部提供？==这是一种理想的方法，在这种情况下，这些模块依然保证了很好的独立性。但问题在于并不是所有的unsafe操作都能以trait来进行约束。这时候模块就不得不依赖我们提供的安全抽象层。

系统中的域，应该可以分为两种形式：

1. 模块之上的封装
2. 内核子系统(可能由多个模块 + 自定义的逻辑)

对于模块之上的封装，大多数针对设备驱动（+文件系统），不管模块是否依赖我们的安全抽象层，他们的使用都可以按照传统的实现直接进行函数调用并一起链接成可执行文件，但是对于域的定义，我们是需要这些模块可以被独立编译，并以特定的方式与其它域进行交互的，这些定义体现在接口的进一步封装和单独的编译链接上，而这些都可以只在已有的模块上添加一层封装即可。

而对于不能直接由一个模块构成的域，这大多数是系统内部的各个子系统，比如文件子系统、网络子系统、中断子系统，我们把这些子系统作为一个域来构建。这些域内部通常是与本系统设计密切相关的内容。



## 故障容错

虽然内存隔离机制可以停止跨模块的故障传播，但故障仍可能发生在软件模块内或由于硬件环境而发生。因此，还需要容错来实现高可靠性，其包括错误检测、错误恢复和故障处理。

### 错误检测

这部分概述从Rustpi论文中获取：

软件和硬件都可以检测到错误。

大部分检测方法假设底层硬件环境正确且完美地工作。然而，在真实的环境下，瞬态硬件故障是不可避免的。当这种故障发生时，正在运行的系统的控制流和数据流都可能损坏。因此，Rustpi利用控制流完整性（CFI）技术来检测由破坏返回地址的瞬时硬件错误引起的意外函数跳转。

### 错误恢复

错误恢复是将损坏的系统恢复到正常状态。

这意味着在发生错误时系统不应该直接崩溃，而是可选地

1. 向上层调用者返回错误，这通常由良好的错误处理支持
2. 或者结束当前进程，这通常是进程违反了规定

### 故障处理

控制流的展开并不意味着故障恢复已经完成。例如，系统调用可以展开并向用户空间返回错误。然而，系统调用通常由多个步骤组成，其中可能发生资源分配。如果中间的一步引发恐慌，那么之前分配的所有资源都需要得到处理。

Rust的展开也有助于在展开堆栈框架中删除（释放）局部变量。通过为所有内核资源结构实现了Drop trait，我们可以在控制流的展开过程中自动释放这些资源，因此在展开过程中不会泄露内核的资源，这种异常处理在C语言内核中要困难的多。





## 实现

这部分描述了如何在Rust语言中实施三个主要的目标。

### 接口定义

每个隔离域都向外提供功能，这些功能使用rust的`trait` 进行表示。系统启动后会加载各个隔离域，并得到一个代表隔离域的对象。

```rust
pub trait BlkDevice: Send + Sync {
    fn read(&self, block: u32, data: RRef<[u8; 4096]>) -> AlienResult<RRef<[u8; 4096]>>;
    fn write(&self, block: u32, data: &RRef<[u8; 4096]>) -> AlienResult<usize>;
    fn get_capacity(&self) -> AlienResult<u64>;
}
```

### 内存隔离

1. 使用`safe rust` 实现各个隔离的子系统：这意味着实现中不允许出现任何`unsafe` 操作。在未来，我们可以借助形式化验证、程序检查等技术放宽这个限制
2. 使用两级内存分配器管理整个系统的内存和隔离域的内存
   1. 第一级分配器用于向隔离域分配页大小的内存
   2. 第二级分配器负责隔离域内部的小粒度内存分配，这通常是指rust的`[global_allocator]`
3. 封装不安全的低级操作：一些隔离域必须与低级的硬件进行交互，我们需要将对硬件的访问封装在安全的rust中。
   1. 隔离域只能依赖我们提供的安全封装实现上层逻辑
   2. 隔离域可以依赖TCB请求一些必要功能

在实施阶段，我们暂时忽略第一条的`safe rust`限制，从而降低已有代码的不必要重写，我们假设已有的`unsafe`代码不会破坏内存隔离这一原则。

### 故障隔离

为了强制执行故障隔离，我们需要依靠调用代理来干预所有跨域调用。为了确保隔离和安全，代理在每个包装函数内实现以下内容：

1. 代理在执行调用之前检查域是否处于活动状态。如果域处于活动状态，代理会通过更新内核中的状态来记录线程在域之间移动的事实。当域崩溃时，我们使用此信息来展开域内执行的所有线程
2. 对于每次调用，代理都会创建一个轻量级延续，捕获跨域调用之前线程的状态。延续允许我们展开线程的执行，并向调用者返回错误。
3. 代理移动作为域之间参数传递的所有 RRef<T> 的所有权，或更新所有不可更改借用的引用的借用计数

代理只是对域对象的简单封装。

### 故障恢复

我们的故障恢复目前只会针对几个简单的隔离子系统(几个驱动程序)。

- 为了实现故障恢复，隔离域可能需要保存初始化域所需的资源，比如其它隔离域的对象引用。
- 针对可恢复的隔离域，在执行故障隔离时，线程的展开并不会返回错误，代理对象会尝试重新对隔离域进行初始化，并再次执行跨域调用。

- 需要注意的是当跨域调用时如果我们使用不可变参数进行通信时，对隔离域的重新调用可以不需要额外的拷贝，对于使用拥有所有权的参数进行通信时，为了实施对隔离域的重新调用，我们需要对参数进行拷贝。

### 通信

使用共享堆来进行域间通信

1. 共享堆限制了在域间通信时传递的数据，避免隔离域拥有其它域的数据
2. 利用rust的所有权机制，使得传递的数据只能有一个所有者，这可以避免数据传递后被原来的域所修改
3. 通过移动数据的所有权，或者使用不可变数据，我们可以避免对数据的额外拷贝

### Linux扩展

- [ ] 如何为隔离域在Linux内核中实施几个必要的基础设施？
- [ ] 在将隔离域引入内核时需要针对内核的接口进行什么样的修改？
- [ ] 如何让这个过程变得更简单？



### 动态加载和更新

借助于域的概念，域都是被单独编译的并作为一个可执行ELF文件被加载到内核地址空间中。这意味着：

1. TCB部分(包含域的loader)和域是分离的
2. 域的接口和实现是分离的

借助于这两个方法，可以进一步扩展域的故障隔离，实现域的动态加载和更新。

- 域的接口和实现是分离的，意味着域可以在系统启动后再被编译
- TCB和域是分离的，意味着域可以被在任何时刻加载到内核地址空间中



域的更新方式：

1. 事先编译好，放在磁盘中  【Done】
2. 系统启动后，在外部编译，并通过网络传送 【Doing】
3. 系统启动后，直接在系统中编译    【Wait】



在域的实现中，每个域并不直接通过真正的域对象进行交互，而是通过域代理对象交互。并且域代理对象会执行一些跟隔离相关的功能。这个代理对象可以方便地作用到域的更新替换上面。

1. 每个域代理对象保存了真正的域对象，并通过一个读写锁进行保护
2. 所有的域交互都直接通过读锁进行访问，因此没有锁的竞争
3. 当进行域更新时，通过获取写锁，拿到域的独占权，当拿到独占权后，意味着没有执行流进入到这个域中， 可以安全地进行替换

```rust
#[derive(Debug)]
pub struct LogDomainProxy {
    id: AtomicU64,
    domain: RwLock<alloc::boxed::Box<dyn LogDomain>>,
    old_domain: Mutex<alloc::vec::Vec<alloc::boxed::Box<dyn LogDomain>>>,
    domain_loader: Mutex<DomainLoader>,
}
```

因为域在初始化时可能需要传递参数，因此当域被更新的时候，它需要知道旧域初始化时候的参数。针对这种情况，现在的解决方法是：

- 每个域都有`init` 函数，这个`init` 函数的参数就是需要保存的内容
- 在调用域代理对象的这个函数时，可以将这个参数保存下来

```rust
#[derive(Debug)]
pub struct BlkDomainProxy {
    id: AtomicU64,
    domain: RwLock<alloc::boxed::Box<dyn BlkDeviceDomain>>,
    old_domain: Mutex<alloc::vec::Vec<alloc::boxed::Box<dyn BlkDeviceDomain>>>,
    domain_loader: Mutex<DomainLoader>,
    resource: Once<Range<usize>>,
}

impl BlkDeviceDomain for BlkDomainProxy {
    fn init(&self, device_info: Range<usize>) -> AlienResult<()> {
        self.resource.call_once(|| device_info.to_owned());
        self.domain.read().init(device_info)
    }
}
```

- 这种方法只能针对一些较为简单的参数类型，因为他们是直接通过`to_owned()` 方法转换为带单一所有权的数据

**局限**： 目前的这些更新方法所适用的域大多是底层的驱动以及一些其它功能比较单一的域。一个需要解决的问题是，当一个执行流在一个域内发生了任务切换，那么这个时候就无法更新这个域。

1. 当发生了任务切换，意味着这个域的读锁被持有，无法获取写锁
2. 这个域如果被更新，切换出去的执行流无法回到正确的位置，因为当执行流被切换回来后它的执行的代码是旧的域的代码

这个问题可以通过使**更新域的进程挂起** 可以解决。也就是在一个进程A更新域的时候：

1. 首先尝试获取写锁，如果无法得到，说明有执行流正在这个域中，也许正在执行，也许已经发生任务切换
2. 在无法得到的情况下，A 也发生任务切换，让其它任务先执行
   1. 当下一次调度到A的时候，再次尝试获取，并重复上述步骤
   2. 最终A可以拿到域的写锁，独占锁
3. 在得到的情况下就可以按照上文的描述进行更新

这里还可能出现的一种情况是，<font color = red>当一个线程执行退出时，可能会发生读锁永远无法释放的问题。 </font>

```
SyscallDomain
	->TaskDomain
	->SchedulerDomain
		->switch_task
```

- 线程依次获得了`SyscallDomain ` `TaskDomain` 的 读锁访问，并最终得到`schedulerDomain`的读锁
-  线程在`SchedulerDomain` 结束了生命周期并切换到下一个任务，这个时候读锁没有被释放掉。



> 寻找一种无锁方式，避免锁的使用？
>
> RCU or Other？



1. 在解决上面这个问题，对于无状态域的更新基本就没有太大的障碍了。
2. 紧接着考虑有状态域的更新

### [有状态域的动态更新机制](./state.md)



## rust检查工具

[Rust 程序 Bug 静态检测工具 MirChecker](https://rustmagazine.github.io/rust_magazine_2021/chapter_11/mirchecker.html#%E8%AE%BA%E6%96%87%E5%AF%BC%E8%AF%BBrust-%E7%A8%8B%E5%BA%8F-bug-%E9%9D%99%E6%80%81%E6%A3%80%E6%B5%8B%E5%B7%A5%E5%85%B7-mirchecker)

https://github.com/lizhuohua/rust-mir-checker

论文：https://dl.acm.org/doi/10.1145/3460120.3484541



## 其它论文现有的工作

[Unishyper: A Rust-based unikernel enhancing reliability and efficiency of embedded systems](https://www.sciencedirect.com/science/article/pii/S138376212400136X)  论文旨在提高unikernel在嵌入式系统上应用。

Unishyper旨在通过多线程（任务）方法支持SAS中的多个应用程序。**我们的目标是从两个角度来增强这种单进程，多线程系统中的任务之间的隔离：内存访问和故障影响，确保一个任务的崩溃不会对整个系统的稳定运行产生不利影响**。为了在用户和内核代码之间提供内存隔离支持，以及在线程级别上不同用户应用程序之间的隔离，Unishyper设计了基于英特尔MPK [36]的Zone机制，以将代码隔离到线程组中。Unishyper进一步设计了运行时错误处理的线程级展开策略，包括转储错误调用链、资源清理和线程重启尝试。



## 规划

我们会按照几个阶段逐步将已有的Alien OS内核转变成一个隔离的内核。

- [x] 第一阶段实施

  - [x] 原型系统的验证：这一阶段主要是对隔离的几个核心概念做一个简单的演示，以验证使用rust语言实现的可行性。

    - [x] 对隔离子系统的划分：内核中有多个子系统，我们需要考察如何划分子系统才可以做到性能和隔离效果兼顾

      - 粒度大意味着接口可以更简单，域间通信的次数更少，带来的开销也减小，但因为隔离边界的扩大导致隔离域出现故障的概率更高了
      - 粒度小则可能会让系统内部的隔离域数量增大，导致频繁的域间通信，开销增大，但是较小的边界可以把错误限制在更小的范围
      - [x] 目前的想法暂定的几个隔离域：
        - [x] 设备驱动: 块设备+网络设备
        - [x] 文件系统 + 虚拟文件系统

    - [x] 隔离域实现的基础设施

      - [x] 对内核TCB的功能依赖：两级分配器 + 共享堆
      - [x] 各个驱动域依赖的硬件安全封装
      - [x] 接口定义和代码自动生成


  - [x] 实现各个隔离域并组装完整的系统


  - [ ] 测试

- [ ] 第二阶段Linux内核扩展

  - [ ] 准备隔离域所需的基础设施
  - [ ] 逐步引入隔离域

在每个实施阶段，我们都可能对其中的机制或方法进行修改和修正。



TODO

- [ ] 使用unwind机制，而不是当前的状态保存机制？-> 更好的故障容错机制
- [ ] 

