//! This descrption comes from Theseus at https://www.theseus-os.com/Theseus/doc/src/unwind/lib.rs.
//!
//! Support for unwinding the call stack and cleaning up stack frames.
//!
//! Uses DWARF debugging information (`.eh_frame` and `.gcc_except_table` sections) from object files.
//! It can also be used to generate stack traces (backtrace) using only that debug information
//! without using frame pointer registers.
//!
//! The general flow of the unwinding procedure is as follows:
//! * A panic occurs, which jumps to the panic entry point.
//! * The panic entry point invokes the panic_wrapper, which handles said panic
//!   by invoking `start_unwinding()` in this crate with the reason for the panic.
//! * `start_unwinding()` generates an iterator over all stack frames in the call stack
//!   (the knowledge for which comes from parsing the .eh_frame section).
//! * `start_unwinding()` creates an unwinding context, which contains the stack frame iterator,
//!   the reason for the panic, and a reference to the current task being unwound.
//!   It then skips the first several stack frames, which correspond to the panic and unwind handlers themselves.
//!   Note that we cannot unwind those frames because they contain resources that we are currently using for unwinding purposes.
//! * At any point hereafter, the unwinding context must be manually cleaned up.
//! * `start_unwinding()` calls `continue_unwinding()`, which contains the bulk of the unwinding logic.
//! * `continue_unwinding()` iterates to the "next" stack frame (the previous frame in the call stack),
//!   and invokes its cleanup routine (landing pad) if it has one.
//! * Once the cleanup routine is complete, it jumps to `_Unwind_Resume` automatically.
//!   This cannot be changed and is an artifact of how unwinding routines are generated by the compiler.
//! * `_Unwind_Resume` is defined alongside the panic entry pointer, and is nothing more
//!   than a simple wrapper that invokes `continue_unwinding()` here.
//! * `continue_unwinding()` continues iterating up the call stack.
//!   Once it reaches the end of the call stack (or an error occurs),
//!   we invoke a finalizer routine called `cleanup_unwinding_context()`.
//! * In `cleanup_unwinding_context()`, the unwinding context pointer is recovered and all unwinding resources are freed.
//!   Finally, the task is marked as killed so it can no longer be scheduled in.
//!
//!
//! The flow of some functions was inspired by gcc's `libunwind`
//! and from `gimli/unwind-rs/src/glue.rs`.
#![no_std]
#![feature(core_intrinsics)]
#![allow(internal_features)]
#![feature(naked_functions)]
extern crate alloc;
#[macro_use]
extern crate log;

extern crate preprint;

use alloc::boxed::Box;
use core::fmt;

use arch::*;
use fallible_iterator::FallibleIterator;
use gimli::{read::RegisterRule, CfaRule, Pointer, UninitializedUnwindContext, UnwindSection};
use preprint::pprint as print;
use registers::Registers;
#[cfg(target_arch = "aarch64")]
#[path = "arch/aarch64.rs"]
pub mod arch;

#[cfg(target_arch = "riscv64")]
#[path = "arch/riscv64.rs"]
pub mod arch;

mod addr2line;
pub mod catch;
pub mod elf;
pub mod lsda;
pub mod registers;

pub struct UnwindingContext {
    skip: usize,
    #[allow(unused)]
    reason: usize,
    stack_frame_iter: StackFrameIter,
}

pub struct StackFrame {
    // Pointer to LSDA.
    lsda: Option<u64>,
    // Initial address of function.
    initial_address: u64,
    // Call site address.
    call_site_address: u64,
}

pub struct StackFrameIter {
    /// The values of the registers that exited during the stack frame
    /// that is currently being iterated over.
    ///
    /// These register values will change on each invocation of `next()`
    /// as different stack frames are successively iterated over.
    registers: Registers,
    /// State: (Caller, CFA)
    /// Unwinding state related to the previous frame in the call stack:
    /// a reference to its row/entry in the unwinding table,
    /// and the Canonical Frame Address (CFA value) that is used to determine the next frame.
    state: Option<(u64, u64)>,
    /// This is set to true when the unwinding process was from exception/interrupt,
    /// We have to find the nearst landing pad during stackframe iteration.
    from_exception: bool,
}

impl fmt::Debug for StackFrameIter {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "StackFrameIter {{\nRegisters: {:?},\nstate: {:#X?}\n}}",
            self.registers, self.state
        )
        // write!(f, "StackFrameIter {{\nRegisters: {:?}\n}}", self.registers)
    }
}

impl StackFrameIter {
    pub fn new(registers: Registers, from_exception: bool) -> Self {
        StackFrameIter {
            registers,
            state: None,
            from_exception,
        }
    }

    pub fn from_exception(&self) -> bool {
        self.from_exception
    }

    pub fn set_from_exception(&mut self, from_exception: bool) {
        self.from_exception = from_exception
    }
}

// Here we implement the main logic for traversing up the call stack.
impl FallibleIterator for StackFrameIter {
    type Item = StackFrame;
    type Error = &'static str;

    fn next(&mut self) -> Result<Option<Self::Item>, Self::Error> {
        let registers = &mut self.registers;
        // If state is empty, it's the beginning of the call stack.
        if let Some((caller, cfa)) = self.state.take() {
            let mut new_regs = registers.clone();
            new_regs[REG_RETURN_ADDRESS] = None;
            // The stack pointer is defined to be the previously-calculated CFA.
            new_regs[REG_STACK_POINTER] = Some(cfa);
            let base_addrs = elf::base_addresses();
            let eh_frame = gimli::read::EhFrame::new(elf::eh_frame_slice(), gimli::NativeEndian);
            let mut unwind_ctx = UninitializedUnwindContext::new();
            let fde = eh_frame
                .fde_for_address(&base_addrs, caller, gimli::EhFrame::cie_from_offset)
                .map_err(|_e| {
                    error!("gimli error: {:?}", _e);
                    "gimli error while finding FDE for address"
                })?;
            let row = fde
                .unwind_info_for_address(&eh_frame, &base_addrs, &mut unwind_ctx, caller)
                .map_err(|_e| {
                    error!("gimli error: {:?}", _e);
                    "gimli error while finding unwind info for address"
                })?;
            for &(reg_num, ref rule) in row.registers() {
                // debug!("Looking at register rule:  {:?} {:?}", reg_num, rule);
                // The stack pointer (RSP) is given by the CFA calculated during the previous iteration;
                // there should *not* be a register rule defining the value of the RSP directly.
                if reg_num == REG_STACK_POINTER {
                    continue;
                }
                new_regs[reg_num] = match *rule {
                    RegisterRule::Undefined
                    | RegisterRule::Expression(_)
                    | RegisterRule::ValExpression(_)
                    | RegisterRule::Architectural => {
                        error!("unsupported rule {:?}", *rule);
                        return Err("unsupported rule");
                    }
                    RegisterRule::SameValue => registers[reg_num],
                    RegisterRule::Register(other) => registers[other],
                    // This is the most common register rule (in fact, the only one we've seen),
                    // so we may have to adapt the logic herein for use in other rules.
                    RegisterRule::Offset(offset) => {
                        let value =
                            unsafe { (cfa.wrapping_add(offset as u64) as *const u64).read() };
                        Some(value)
                    }
                    RegisterRule::ValOffset(offset) => Some(cfa.wrapping_add(offset as u64)),
                };
            }
            *registers = new_regs;
        }
        // The return address (used to find the caller's stack frame) should be in the newly-calculated register set.
        // If there isn't one, or if it's 0, then we have reached the beginning of the call stack, and are done iterating.
        let return_address = match registers[REG_RETURN_ADDRESS] {
            Some(0) | None => return Ok(None),
            Some(ra) => ra,
        };
        // The caller should be the last instruction to return address.
        let caller = return_address - 4;

        // debug!("return_address {return_address:#x}");
        // addr2line::print_addr2line(return_address);
        // debug!("caller {caller:#x}");
        // addr2line::print_addr2line(caller);

        // Get Caller pointer's FDE and UnwindtableRow according to eh_frame info.
        let base_addrs = elf::base_addresses();
        let eh_frame = gimli::read::EhFrame::new(elf::eh_frame_slice(), gimli::NativeEndian);
        let mut unwind_ctx = UninitializedUnwindContext::new();
        let fde = eh_frame
            .fde_for_address(&base_addrs, caller, gimli::EhFrame::cie_from_offset)
            .map_err(|_e| {
                error!("gimli error: {:?}", _e);
                "gimli error while finding FDE for address"
            })?;
        let row = fde
            .unwind_info_for_address(&eh_frame, &base_addrs, &mut unwind_ctx, caller)
            .map_err(|_e| {
                error!("gimli error: {:?}", _e);
                "gimli error while finding unwind info for address"
            })?;

        // Get canonical frame address according to the rules from UnwindTableRow.
        // It's usually the specific offset of sp register.
        let cfa = match *row.cfa() {
            CfaRule::RegisterAndOffset { register, offset } => {
                let reg_value = registers[register].ok_or_else(|| {
                    error!("cfa reg none");
                    "cfa reg none"
                })?;
                reg_value.wrapping_add(offset as u64)
            }
            CfaRule::Expression(_) => {
                error!("cfa expression");
                return Err("cfa expression");
            }
        };

        // debug!("initial_address: {:#X}", fde.initial_address());
        // debug!("cfa: {:#X}", cfa);

        // Generate next stack frame.
        let frame = StackFrame {
            lsda: fde.lsda().map(|x| unsafe {
                match x {
                    Pointer::Direct(x) => x,
                    Pointer::Indirect(x) => *(x as *const u64),
                }
            }),
            initial_address: fde.initial_address(),
            call_site_address: caller,
        };

        self.state = Some((caller, cfa));
        Ok(Some(frame))
    }
}

/// Starts the unwinding procedure for the current thread from exception.
/// by working backwards up the call stack starting from the exception context frame.
///
/// # Arguments
/// * `registers`: exception context frame.
///
pub fn unwind_from_exception(registers: Registers) -> ! {
    debug!("unwind_from_exception:\n{:?}", registers);

    let ctx = Box::new(UnwindingContext {
        skip: 0,
        reason: 0x1,
        stack_frame_iter: StackFrameIter::new(registers, true),
    });
    // let _ = ctx.stack_frame_iter.next();
    let ctx = Box::into_raw(ctx);
    unwind(ctx);
    cleanup(ctx);
    error!("unwind_from_exception failed!");
    loop {}
}

/// Starts the unwinding procedure for the current thread from panic.
/// by working backwards up the call stack starting from the current stack frame.
///
/// # Arguments
/// * `stack_frames_to_skip`: the number of stack frames that should be skipped in order to avoid unwinding them.
///   For example, for a panic, the first `5` frames in the call stack can be ignored.
///
pub fn unwind_from_panic(stack_frames_to_skip: usize) -> ! {
    debug!(
        "unwind_from_panic: stack_frames_to_skip {}",
        stack_frames_to_skip
    );
    // Be careful about the resource leaking on the stack.
    let ctx = Box::into_raw(Box::new(UnwindingContext {
        skip: stack_frames_to_skip,
        reason: 0x2,
        stack_frame_iter: StackFrameIter::new(Registers::default(), false),
    }));

    // IMPORTANT NOTE!!!!
    // From this point on, if there is a failure
    // we need to free the unwinding context pointer to avoid leaking things.

    // This is an internal assembly function in arch/aarch64.rs
    // that the current register values by pushing them onto the stack
    // before invoking the function "unwind_recorder" with those register values as the only argument.
    // This is needed because the unwind info tables describe register values as operations (offsets/addends)
    // that are relative to the current register values, so we must have those current values as a starting point.
    //
    // The argument is the pointer of the UnwindingContext.
    unsafe {
        unwind_trampoline(ctx as usize);
    }
    cleanup(ctx);
    error!("unwind_from_panic failed!");
    loop {}
}

fn unwind_from_panic_stub(registers: Registers, ctx2: *mut UnwindingContext) {
    // Set the proper register values before start the actual unwinding procedure.
    let ctx = unsafe { &mut *ctx2 };
    ctx.stack_frame_iter.registers = registers;

    // Skip the first several frames, e.g., to skip unwinding the panic entry point functions themselves.
    for _i in 0..ctx.skip {
        let _ = ctx.stack_frame_iter.next();
    }
    unwind(ctx2);
}

/// Main unwind function.
/// Only return when unwind failed, otherwise jump to a landing pad.
fn unwind(ctx: *mut UnwindingContext) {
    let stack_frame_iter = unsafe { &mut (*ctx).stack_frame_iter };
    match stack_frame_iter.next() {
        Err(e) => {
            error!("next failed with {}", e);
            return;
        }
        Ok(None) => {
            // LSDA not found during unwind, just return.
            error!("no frame left");
            return;
        }
        Ok(Some(frame)) => {
            print!("Unwinding StackFrame:\n{}", frame);
            match frame.lsda {
                None => {
                    // LSDA not found in this call frame, just keep unwinding.
                    warn!("frame has no lsda, continue");
                    return unwind(ctx);
                }
                Some(lsda) => {
                    print!("lsda: {lsda:#x}\n");
                    // Resolve the gcc execption table on LSDA address.
                    match elf::find_lsda_data(lsda as usize) {
                        None => {
                            error!("cannot find lsda in elf");
                            return;
                        }
                        Some(lsda_slice) => {
                            let table = lsda::GccExceptTableArea::new(
                                lsda_slice,
                                gimli::NativeEndian,
                                frame.initial_address,
                            );

                            // table.dump_call_size_entry_of_address(frame.call_site_address);

                            let entry = match table
                                .call_site_table_entry_for_address(frame.call_site_address)
                            {
                                Ok(x) => {
                                    if x.landing_pad_address().is_some() {
                                        x
                                    } else {
                                        let mut iter = match table.call_site_table_entries() {
                                            Ok(iter) => iter,
                                            Err(_) => {
                                                error!("call_site_table_entries failed");
                                                return;
                                            }
                                        };
                                        let mut closest_entry = None;
                                        loop {
                                            let next = match iter.next() {
                                                Ok(next) => next,
                                                Err(_) => {
                                                    error!("iter call site table failed");
                                                    return;
                                                }
                                            };
                                            if let Some(entry) = next {
                                                if stack_frame_iter.from_exception()
                                                    && entry.landing_pad_address().is_some()
                                                {
                                                    debug!(">>>>>>>>>>>>>>>>>");
                                                    debug!(
                                                    	"Unwind from exception, find closest_entry {:x?} {:x?} {:x?}",
                                                    	entry.range_of_covered_addresses(),
                                                    	entry.landing_pad_address(),
                                                    	entry.action_offset()
                                                	);
                                                    debug!("<<<<<<<<<<<<<<<<<");
                                                    closest_entry = Some(entry);
                                                    break;
                                                }
                                            } else {
                                                break;
                                            }
                                        }
                                        if let Some(closest_entry) = closest_entry {
                                            closest_entry
                                        } else {
                                            x
                                        }
                                    }
                                }
                                Err(e) => {
                                    warn!(
                                        "call site has no entry {:016x} {}",
                                        frame.call_site_address, e
                                    );
                                    let mut iter = match table.call_site_table_entries() {
                                        Ok(iter) => iter,
                                        Err(_) => {
                                            error!("call_site_table_entries failed");
                                            return;
                                        }
                                    };
                                    let mut closest_entry = None;
                                    loop {
                                        let next = match iter.next() {
                                            Ok(next) => next,
                                            Err(_) => {
                                                error!("iter call site table failed");
                                                return;
                                            }
                                        };
                                        if let Some(entry) = next {
                                            if entry.range_of_covered_addresses().start
                                                < frame.call_site_address
                                            {
                                                closest_entry = Some(entry);
                                            }
                                        } else {
                                            break;
                                        }
                                    }
                                    if let Some(closest_entry) = closest_entry {
                                        closest_entry
                                    } else {
                                        error!("no closest entry");
                                        return;
                                    }
                                }
                            };
                            let landing_pad = match entry.landing_pad_address() {
                                Some(lpa) => lpa,
                                _ => {
                                    warn!("frame has lsda but no landing pad, continue");
                                    return unwind(ctx);
                                }
                            };

                            #[cfg(target_arch = "aarch64")]
                            unsafe {
                                // brk #?
                                if (landing_pad as usize as *const u32).read() & 0xFF_E0_00_00
                                    == 0xd4_20_00_00
                                {
                                    warn!("land at {:016x} is `brk #?`, continue", landing_pad);
                                    return unwind(ctx);
                                }
                            }
                            info!("land at {:016x}", landing_pad);
                            // addr2line::print_addr2line(landing_pad);

                            let mut regs = stack_frame_iter.registers.clone();
                            #[cfg(not(feature = "std"))]
                            {
                                regs[REG_ARGUMENT] = Some(ctx as u64);
                            }
                            #[cfg(feature = "std")]
                            {
                                regs[REG_ARGUMENT] = Some(crate::exported::get_global_payload());
                            }

                            if stack_frame_iter.from_exception() {
                                stack_frame_iter.set_from_exception(false);
                                unsafe {
                                    land(&regs, landing_pad, true);
                                }
                            } else {
                                unsafe {
                                    land(&regs, landing_pad, false);
                                }
                            }
                            // Never return!
                        }
                    }
                }
            }
        }
    };
}

/// Drop `UnwindingContext` when unwind fails.
/// This function should be invoked when the unwinding procedure is finished, or cannot be continued any further.
/// It cleans up the `UnwindingContext` object pointed to by the given pointer and marks the current task as killed.
fn cleanup(ctx: *mut UnwindingContext) {
    let ctx = unsafe { Box::from_raw(ctx) };
    drop(ctx);
}

/// This function is called by `_Unwind_Resume`
///
/// An unwind process might land on multiple landing pads.
/// In the end of in-betweeen landing pad, _Unwind_Resume will be called to resume unwinding.
///
/// # Argument
///
/// * `arg` - pointer to `UnwindingContext`
pub fn unwind_resume(arg: usize) -> ! {
    let ctx = arg as *mut UnwindingContext;
    unwind(ctx);
    cleanup(ctx);
    error!("unwind failed!");
    loop {}
}
